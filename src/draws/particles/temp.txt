Can you analyze this and tell me if there's stuff wrong with it?

Or some things that I can change for performance improvements.

/005   fragment-draw.glsl
/002   fragment-update.glsl
/001   particles.ts
/003   vertex-draw.glsl
/004   vertex-update.glsl

particles:

import { Utilities } from "../../utilities";
import vertexUpdate from "./vertex-update.glsl";
import vertexDraw from "./vertex-draw.glsl";
import fragmentUpdate from "./fragment-update.glsl";
import fragmentDraw from "./fragment-draw.glsl";

export class Particles {
  constructor(private readonly canvas: HTMLCanvasElement) { }

  readonly setup = () => {
    const gl = this.canvas.getContext("webgl2");
    if (!gl) throw new Error("Failed to get WebGL2 context");

    const vertexUpdateShader = Utilities.WebGL.Setup.compileShader(gl, "vertex", vertexUpdate);
    const vertexDrawShader = Utilities.WebGL.Setup.compileShader(gl, "vertex", vertexDraw);
    const fragmentUpdateShader = Utilities.WebGL.Setup.compileShader(gl, "fragment", fragmentUpdate);
    const fragmentDrawShader = Utilities.WebGL.Setup.compileShader(gl, "fragment", fragmentDraw);

    const updateProgram = Utilities.WebGL.Setup.linkTransformFeedbackProgram(
      gl,
      vertexUpdateShader,
      fragmentUpdateShader,
      ["newPosition"],
      "separate",
    );

    const drawProgram = Utilities.WebGL.Setup.linkProgram(gl, vertexDrawShader, fragmentDrawShader);

    Utilities.WebGL.Canvas.resizeCanvasToDisplaySize(this.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    this.main(gl, updateProgram, drawProgram);
  };

  private readonly createRandomArray = (count: number, minRange: number, maxRange: number) => {
    const temp: number[] = [];
    for (let i = 0; i < count; i++) {
      temp.push(Utilities.Random.range(minRange, maxRange));
    }
    return temp;
  };

  private readonly main = (gl: WebGL2RenderingContext, updateProgram: WebGLProgram, drawProgram: WebGLProgram) => {
    // --- Locations ---

    const locations = {
      update: {
        aOldPosition: gl.getAttribLocation(updateProgram, "a_oldPosition"),
        aVelocity: gl.getAttribLocation(updateProgram, "a_velocity"),
        uDeltaTime: gl.getUniformLocation(updateProgram, "u_deltaTime"),
        uCanvasDimensions: gl.getUniformLocation(updateProgram, "u_canvasDimensions"),
      },
      draw: {
        position: gl.getAttribLocation(drawProgram, "position"), // todo: change later
      },
    };

    // --- Data ---

    const particlesCount = 1000;
    const positions = new Float32Array(this.createRandomArray(particlesCount * 2, 0, 1));
    const velocities = new Float32Array(this.createRandomArray(particlesCount * 2, 0.01, 0.1));

    // --- Buffers ---

    const positionBuffer1 = gl.createBuffer()!;
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer1);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

    const positionBuffer2 = gl.createBuffer()!;
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

    const velocityBuffer = gl.createBuffer()!;
    gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);

    // --- Vertex Array Objects ---

    // update position VAO 1
    const updateVA1 = gl.createVertexArray();
    gl.bindVertexArray(updateVA1);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer1); // 1
    gl.enableVertexAttribArray(locations.update.aOldPosition);
    gl.vertexAttribPointer(locations.update.aOldPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
    gl.enableVertexAttribArray(locations.update.aVelocity);
    gl.vertexAttribPointer(locations.update.aVelocity, 2, gl.FLOAT, false, 0, 0);

    // update position VAO 2
    const updateVA2 = gl.createVertexArray();
    gl.bindVertexArray(updateVA2);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2); // 2
    gl.enableVertexAttribArray(locations.update.aOldPosition);
    gl.vertexAttribPointer(locations.update.aOldPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
    gl.enableVertexAttribArray(locations.update.aVelocity);
    gl.vertexAttribPointer(locations.update.aVelocity, 2, gl.FLOAT, false, 0, 0);

    // draw VAO 1
    const drawVA1 = gl.createVertexArray();
    gl.bindVertexArray(drawVA1);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer1); // 1
    gl.enableVertexAttribArray(locations.draw.position);
    gl.vertexAttribPointer(locations.draw.position, 2, gl.FLOAT, false, 0, 0);

    // draw VAO 2
    const drawVA2 = gl.createVertexArray();
    gl.bindVertexArray(drawVA2);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2); // 2
    gl.enableVertexAttribArray(locations.draw.position);
    gl.vertexAttribPointer(locations.draw.position, 2, gl.FLOAT, false, 0, 0);

    // --- Transform Feedback ---

    const tf1 = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf1); // 1
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, positionBuffer1); // 1

    const tf2 = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf2); // 2
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, positionBuffer2); // 2

    // --- Unbind leftovers ---

    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);

    // --- Swaps ---

    let current = {
      updateVA: updateVA1, // Read from position1.
      tf: tf2, // Write to position2.
      drawVA: drawVA2, // Draw with position2.
    };

    let next = {
      updateVA: updateVA2, // Read from position2.
      tf: tf1, // Write to position 1.
      drawVA: drawVA1, // Draw with position 1.
    };

    // --- Render ---

    let timeThen: number = 0;

    const render = (timeNow: number) => {
      timeNow *= 0.001;
      const deltaTime: number = timeNow - timeThen;
      timeThen = timeNow;

      // --- Compute ---

      // Compute the new positions.
      gl.useProgram(updateProgram);
      gl.bindVertexArray(current.updateVA);
      gl.uniform2f(locations.update.uCanvasDimensions, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(locations.update.uDeltaTime, deltaTime);

      // Turn off the fragment shader.
      gl.enable(gl.RASTERIZER_DISCARD);

      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, current.tf);
      gl.beginTransformFeedback(gl.POINTS);
      gl.drawArrays(gl.POINTS, 0, particlesCount);
      gl.endTransformFeedback();
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

      // Turn on using fragment shaders again.
      gl.disable(gl.RASTERIZER_DISCARD);

      // Draw the particles.
      gl.useProgram(drawProgram);
      gl.bindVertexArray(current.drawVA);
      gl.drawArrays(gl.POINTS, 0, particlesCount);

      // --- Swap ---
      const temp = current;
      current = next;
      next = temp;

      requestAnimationFrame(render);
    };

    requestAnimationFrame(render);
  };
}

fragment-draw:

#version 300 es
precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(1, 0, 0, 1);
}

vertex-draw:

#version 300 es

in vec2 position;

uniform mat4 matrix; 

void main() {
  gl_Position = vec4(position, 0, 1);
  gl_PointSize = 5.0;
}

fragment-update:

#version 300 es
precision highp float;

void main() {}


vertex-update:

#version 300 es

in vec2 a_oldPosition;
in vec2 a_velocity;

uniform float u_deltaTime;
uniform vec2 u_canvasDimensions; 

out vec2 newPosition;

// vec2 euclideanModulo(vec2 n, vec2 m) { 
//   return mod(mod(n, m) + m, m);
// }

void main() {
  newPosition = a_oldPosition + a_velocity * u_deltaTime;

  if(newPosition.x >= u_canvasDimensions.x) {
    newPosition.x = 0.0;
  } else if (newPosition.x <= 0.0) {
    newPosition.x = u_canvasDimensions.x;
  }

  if(newPosition.y >= u_canvasDimensions.y) {
    newPosition.y = 0.0;
  } else if (newPosition.y <= 0.0) {
    newPosition.y = u_canvasDimensions.y;
  }

  // newPosition = euclideanModulo(newPosition, u_canvasDimensions);
}

